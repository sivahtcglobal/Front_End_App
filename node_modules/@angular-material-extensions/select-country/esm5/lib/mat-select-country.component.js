/**
 * @fileoverview added by tsickle
 * Generated from: lib/mat-select-country.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { FormControl } from '@angular/forms';
import { COUNTRIES_DB } from './db';
import { debounceTime, map, startWith } from 'rxjs/operators';
/**
 * Country interface ISO 3166
 * @record
 */
export function Country() { }
if (false) {
    /** @type {?} */
    Country.prototype.name;
    /** @type {?} */
    Country.prototype.alpha2Code;
    /** @type {?} */
    Country.prototype.alpha3Code;
    /** @type {?} */
    Country.prototype.numericCode;
}
/**
 * @author Anthony Nahas
 * \@since 11.19
 * @version 1.0
 */
var MatSelectCountryComponent = /** @class */ (function () {
    function MatSelectCountryComponent() {
        this.placeHolder = 'Select country';
        this.onCountrySelected = new EventEmitter();
        this.countryFormControl = new FormControl();
        this.countries = COUNTRIES_DB;
    }
    /**
     * @return {?}
     */
    MatSelectCountryComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.filteredOptions = this.countryFormControl.valueChanges
            .pipe(startWith(''), debounceTime(300), map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return _this._filter(value); })));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    MatSelectCountryComponent.prototype._filter = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var filterValue = value.toLowerCase();
        return this.countries.filter((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            return option.name.toLowerCase().includes(filterValue)
                || option.alpha2Code.toLowerCase().includes(filterValue)
                || option.alpha3Code.toLowerCase().includes(filterValue);
        }));
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    MatSelectCountryComponent.prototype.onOptionsSelected = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.selectedCountry = this.countries.find((/**
         * @param {?} country
         * @return {?}
         */
        function (country) { return country.name === $event.option.value; }));
        this.onCountrySelected.emit(this.selectedCountry);
    };
    MatSelectCountryComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mat-select-country',
                    template: "<form>\n  <mat-form-field [appearance]=\"appearance\">\n    <mat-label *ngIf=\"label\">{{label}}</mat-label>\n    <mat-icon class=\"mr-12 s-20 secondary-text\" matSuffix\n              [svgIcon]=\"selectedCountry?.alpha2Code.toLowerCase()\"></mat-icon>\n    <input type=\"text\" [placeholder]=\"placeHolder\" aria-label=\"country\"\n           matInput [formControl]=\"countryFormControl\"\n           [matAutocomplete]=\"auto\" [readonly]=\"readonly\" [disabled]=\"disabled\">\n    <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onOptionsSelected($event)\">\n      <mat-option *ngFor=\"let country of filteredOptions | async\" [value]=\"country?.name\">\n        <mat-icon [svgIcon]=\"country?.alpha2Code.toLowerCase()\"></mat-icon>\n        <small>{{country?.name}} - {{country?.alpha3Code}}</small>\n      </mat-option>\n    </mat-autocomplete>\n  </mat-form-field>\n</form>\n",
                    styles: [""]
                }] }
    ];
    MatSelectCountryComponent.propDecorators = {
        appearance: [{ type: Input }],
        label: [{ type: Input }],
        placeHolder: [{ type: Input }],
        disabled: [{ type: Input }],
        readonly: [{ type: Input }],
        onCountrySelected: [{ type: Output }]
    };
    return MatSelectCountryComponent;
}());
export { MatSelectCountryComponent };
if (false) {
    /** @type {?} */
    MatSelectCountryComponent.prototype.appearance;
    /** @type {?} */
    MatSelectCountryComponent.prototype.label;
    /** @type {?} */
    MatSelectCountryComponent.prototype.placeHolder;
    /** @type {?} */
    MatSelectCountryComponent.prototype.disabled;
    /** @type {?} */
    MatSelectCountryComponent.prototype.readonly;
    /** @type {?} */
    MatSelectCountryComponent.prototype.onCountrySelected;
    /** @type {?} */
    MatSelectCountryComponent.prototype.countryFormControl;
    /** @type {?} */
    MatSelectCountryComponent.prototype.selectedCountry;
    /** @type {?} */
    MatSelectCountryComponent.prototype.countries;
    /** @type {?} */
    MatSelectCountryComponent.prototype.filteredOptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNlbGVjdC1jb3VudHJ5LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLW1hdGVyaWFsLWV4dGVuc2lvbnMvc2VsZWN0LWNvdW50cnkvIiwic291cmNlcyI6WyJsaWIvbWF0LXNlbGVjdC1jb3VudHJ5LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0UsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFbEMsT0FBTyxFQUFDLFlBQVksRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBTTVELDZCQUtDOzs7SUFKQyx1QkFBYTs7SUFDYiw2QkFBbUI7O0lBQ25CLDZCQUFtQjs7SUFDbkIsOEJBQW9COzs7Ozs7O0FBUXRCO0lBQUE7UUFTVyxnQkFBVyxHQUFHLGdCQUFnQixDQUFDO1FBSTlCLHNCQUFpQixHQUEwQixJQUFJLFlBQVksRUFBVyxDQUFDO1FBRWpGLHVCQUFrQixHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7UUFFdkMsY0FBUyxHQUFjLFlBQVksQ0FBQztJQTJCdEMsQ0FBQzs7OztJQXhCQyw0Q0FBUTs7O0lBQVI7UUFBQSxpQkFPQztRQU5DLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFlBQVk7YUFDeEQsSUFBSSxDQUNILFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFDYixZQUFZLENBQUMsR0FBRyxDQUFDLEVBQ2pCLEdBQUc7Ozs7UUFBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQW5CLENBQW1CLEVBQUMsQ0FDbEMsQ0FBQztJQUNOLENBQUM7Ozs7OztJQUVPLDJDQUFPOzs7OztJQUFmLFVBQWdCLEtBQWE7O1lBQ3JCLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFO1FBRXZDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNOzs7O1FBQUMsVUFBQyxNQUFlO1lBQzNDLE9BQUEsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO21CQUM1QyxNQUFNLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7bUJBQ3JELE1BQU0sQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUZ4RCxDQUV3RCxFQUN6RCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFHRCxxREFBaUI7Ozs7SUFBakIsVUFBa0IsTUFBb0M7UUFDcEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUk7Ozs7UUFBQyxVQUFBLE9BQU8sSUFBSSxPQUFBLE9BQU8sQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQXBDLENBQW9DLEVBQUMsQ0FBQztRQUM1RixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNwRCxDQUFDOztnQkEzQ0YsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLDI0QkFBZ0Q7O2lCQUVqRDs7OzZCQUdFLEtBQUs7d0JBQ0wsS0FBSzs4QkFDTCxLQUFLOzJCQUNMLEtBQUs7MkJBQ0wsS0FBSztvQ0FFTCxNQUFNOztJQStCVCxnQ0FBQztDQUFBLEFBNUNELElBNENDO1NBdkNZLHlCQUF5Qjs7O0lBRXBDLCtDQUE0Qzs7SUFDNUMsMENBQXVCOztJQUN2QixnREFBd0M7O0lBQ3hDLDZDQUEyQjs7SUFDM0IsNkNBQTJCOztJQUUzQixzREFBaUY7O0lBRWpGLHVEQUF1Qzs7SUFDdkMsb0RBQXlCOztJQUN6Qiw4Q0FBb0M7O0lBQ3BDLG9EQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NPVU5UUklFU19EQn0gZnJvbSAnLi9kYic7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtkZWJvdW5jZVRpbWUsIG1hcCwgc3RhcnRXaXRofSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge01hdEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQsIE1hdEZvcm1GaWVsZEFwcGVhcmFuY2V9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuLyoqXG4gKiBDb3VudHJ5IGludGVyZmFjZSBJU08gMzE2NlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvdW50cnkge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFscGhhMkNvZGU6IHN0cmluZztcbiAgYWxwaGEzQ29kZTogc3RyaW5nO1xuICBudW1lcmljQ29kZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBhdXRob3IgQW50aG9ueSBOYWhhc1xuICogQHNpbmNlIDExLjE5XG4gKiBAdmVyc2lvbiAxLjBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWF0LXNlbGVjdC1jb3VudHJ5JyxcbiAgdGVtcGxhdGVVcmw6ICdtYXQtc2VsZWN0LWNvdW50cnkuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnbWF0LXNlbGVjdC1jb3VudHJ5LmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgTWF0U2VsZWN0Q291bnRyeUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgYXBwZWFyYW5jZTogTWF0Rm9ybUZpZWxkQXBwZWFyYW5jZTtcbiAgQElucHV0KCkgbGFiZWw6IHN0cmluZztcbiAgQElucHV0KCkgcGxhY2VIb2xkZXIgPSAnU2VsZWN0IGNvdW50cnknO1xuICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbjtcbiAgQElucHV0KCkgcmVhZG9ubHk6IGJvb2xlYW47XG5cbiAgQE91dHB1dCgpIG9uQ291bnRyeVNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8Q291bnRyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPENvdW50cnk+KCk7XG5cbiAgY291bnRyeUZvcm1Db250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gIHNlbGVjdGVkQ291bnRyeTogQ291bnRyeTtcbiAgY291bnRyaWVzOiBDb3VudHJ5W10gPSBDT1VOVFJJRVNfREI7XG4gIGZpbHRlcmVkT3B0aW9uczogT2JzZXJ2YWJsZTxDb3VudHJ5W10+O1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zID0gdGhpcy5jb3VudHJ5Rm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzXG4gICAgICAucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKCcnKSxcbiAgICAgICAgZGVib3VuY2VUaW1lKDMwMCksXG4gICAgICAgIG1hcCh2YWx1ZSA9PiB0aGlzLl9maWx0ZXIodmFsdWUpKVxuICAgICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZpbHRlcih2YWx1ZTogc3RyaW5nKTogQ291bnRyeVtdIHtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5jb3VudHJpZXMuZmlsdGVyKChvcHRpb246IENvdW50cnkpID0+XG4gICAgICBvcHRpb24ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlclZhbHVlKVxuICAgICAgfHwgb3B0aW9uLmFscGhhMkNvZGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSlcbiAgICAgIHx8IG9wdGlvbi5hbHBoYTNDb2RlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyVmFsdWUpXG4gICAgKTtcbiAgfVxuXG5cbiAgb25PcHRpb25zU2VsZWN0ZWQoJGV2ZW50OiBNYXRBdXRvY29tcGxldGVTZWxlY3RlZEV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZENvdW50cnkgPSB0aGlzLmNvdW50cmllcy5maW5kKGNvdW50cnkgPT4gY291bnRyeS5uYW1lID09PSAkZXZlbnQub3B0aW9uLnZhbHVlKTtcbiAgICB0aGlzLm9uQ291bnRyeVNlbGVjdGVkLmVtaXQodGhpcy5zZWxlY3RlZENvdW50cnkpO1xuICB9XG59XG4iXX0=